package org.gbutil.fsm;


import org.apache.logging.log4j.LogManager;
import org.gbutil.Tuple.Tuple2;
import org.gbutil.fsm.node.ISMNode;
import org.gbutil.fsm.node.NodeFactory;
import org.gbutil.fsm.node.connected.DetachedStateException;
import org.gbutil.fsm.node.connected.ISMConnectedNode;
import org.gbutil.fsm.node.end.SMEndNode;
import org.gbutil.graph.TrajanAlgorithm;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Function;

public class FiniteStateMachine<L, S extends IState> implements Function<S, Boolean> {
    private ISMConnectedNode<L, S> mInitialNode;
    private String mName;

    public FiniteStateMachine(String name, ISMConnectedNode<L, S> initialNode) {
        mInitialNode = initialNode;
        mName = name;
    }

    @SuppressWarnings("unchecked")
    public static <L, S extends IState> FiniteStateMachine<L, S> importFSM(String path) {
        FileInputStream fileIn = null;
        ObjectInputStream objIn = null;
        try {
            fileIn = new FileInputStream(path);
            objIn = new ObjectInputStream(fileIn);

            return (FiniteStateMachine<L, S>) objIn.readObject();
        } catch (FileNotFoundException e) {
            LogManager.getRootLogger().error("FSM resource file at '" + path + "' not found");
        } catch (IOException e) {
            LogManager.getRootLogger().fatal("Unexpected error occurred while trying to open resource file", e);
        } catch (ClassNotFoundException | ClassCastException e) {
            LogManager.getRootLogger().error("Unexpected class found in resource file", e);
        } finally {
            try {
                if (fileIn != null) fileIn.close();
                if (objIn != null) objIn.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return null;
    }

    @Override
    public Boolean apply(S state) {
        try {
            return mInitialNode.execute(state);
        } catch (DetachedStateException e) {
            LogManager.getRootLogger().error(
                    String.format(
                            "Option '%s' of node '%s', generated by state '%s' from '%s' is detached",
                            e.option, e.nodeName, state, toString()),
                    e);
            return false;
        }
    }

    @Override
    public String toString() {
        return String.format("FiniteStateMachine{mInitialNode=%s, mName='%s'}", mInitialNode, mName);
    }

    public void attachOpenedTo(L[] possibleOptions) {
        attachOpenedTo(NodeFactory.mkEndNode(false), possibleOptions);
    }

    public void attachOpenedTo(SMEndNode<S> ending, L[] possibleValues) {
        attachOpenedToRec(mInitialNode, ending, possibleValues);
    }

    public List<ISMConnectedNode<L, S>> findOpenedNodes(L[] possibleValues) {
        List<ISMConnectedNode<L, S>> ret = new LinkedList<>();
        Set<ISMConnectedNode<L, S>> observed = new TreeSet<>();
        findOpenedNodes(mInitialNode, observed, possibleValues, ret);
        return ret;
    }

    public List<Set<ISMConnectedNode<L, S>>> findCycles() {
        return TrajanAlgorithm.getStronglyConnectedComponents(buildTrajanRepr(mInitialNode));
    }

    public boolean checkForCycles() {
        return !TrajanAlgorithm.hasStronglyConnectedComponents(buildTrajanRepr(mInitialNode));
    }

    private static <L, S extends IState> Tuple2<List<ISMConnectedNode<L, S>>, boolean[][]> buildTrajanRepr(ISMConnectedNode<L, S> initial) {
        List<ISMConnectedNode<L, S>> graph = new LinkedList<>();
        buildGraph(initial, graph);
        boolean[][] connections = new boolean[graph.size()][graph.size()];
        for (int i = 0; i < connections.length; i++)
            for (int j = 0; j < connections.length; j++)
                connections[i][j] = graph.get(i).isConnectedTo(graph.get(j));

        return new Tuple2<>(graph, connections);
    }

    private static <L, S extends IState> void findOpenedNodes(ISMConnectedNode<L, S> current, Set<ISMConnectedNode<L, S>> observed, L[] options, List<ISMConnectedNode<L, S>> opened) {
        if (observed.contains(current)) return;
        observed.add(current);

        for (L option : options) {
            if (!current.getConnectedNode(option).isPresent() && !opened.contains(current))
                opened.add(current);
            else if (!current.getConnectedNode(option).get().isEndNode())
                findOpenedNodes((ISMConnectedNode<L, S>) current.getConnectedNode(option).get(), observed, options, opened);
        }
    }

    private static <L, S extends IState> void buildGraph(ISMConnectedNode<L, S> current, List<ISMConnectedNode<L, S>> graph) {
        if (graph.contains(current)) return;

        graph.add(current);
        for (ISMNode<S> node : current.getAllConnected())
            if (!node.isEndNode())
                buildGraph((ISMConnectedNode<L, S>) node, graph);
    }

    private static <L, S extends IState> void attachOpenedToRec(ISMNode<S> current, SMEndNode<S> ending, L[] options) {
        if (current.isEndNode()) return;

        ISMConnectedNode<L, S> currentNode = (ISMConnectedNode<L, S>) current;
        for (L l : options) {
            if (currentNode.getConnectedNode(l).isPresent())
                attachOpenedToRec(currentNode.getConnectedNode(l).get(), ending, options);
            else
                currentNode.setConnectedNode(l, ending);
        }

    }
}
